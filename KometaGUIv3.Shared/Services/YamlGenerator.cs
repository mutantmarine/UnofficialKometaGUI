using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using KometaGUIv3.Shared.Models;
using YamlDotNet.Serialization;

namespace KometaGUIv3.Shared.Services
{
    public class YamlGenerator
    {
        public string GenerateKometaConfig(KometaProfile profile)
        {
            var sb = new StringBuilder();
            
            // YAML header
            sb.AppendLine("# yaml-language-server: $schema=https://raw.githubusercontent.com/kometa-team/kometa/nightly/json-schema/config-schema.json");
            sb.AppendLine("## Generated by Kometa GUI v3");
            sb.AppendLine();

            // Plex configuration
            sb.AppendLine("plex:");
            sb.AppendLine($"  url: {profile.Plex.Url}");
            sb.AppendLine($"  token: {profile.Plex.Token}");
            sb.AppendLine($"  timeout: {profile.Plex.Timeout}");
            sb.AppendLine($"  db_cache: {profile.Plex.DbCache}");
            sb.AppendLine($"  clean_bundles: {profile.Plex.CleanBundles.ToString().ToLower()}");
            sb.AppendLine($"  empty_trash: {profile.Plex.EmptyTrash.ToString().ToLower()}");
            sb.AppendLine($"  optimize: {profile.Plex.Optimize.ToString().ToLower()}");
            sb.AppendLine($"  verify_ssl: {profile.Plex.VerifySSL.ToString().ToLower()}");
            sb.AppendLine();

            // TMDb configuration
            sb.AppendLine("tmdb:");
            sb.AppendLine($"  apikey: {profile.TMDb.ApiKey}");
            sb.AppendLine($"  cache_expiration: {profile.TMDb.CacheExpiration}");
            sb.AppendLine($"  language: {profile.TMDb.Language}");
            if (!string.IsNullOrEmpty(profile.TMDb.Region))
            {
                sb.AppendLine($"  region: {profile.TMDb.Region}");
            }
            else
            {
                sb.AppendLine("  region:");
            }
            sb.AppendLine();

            // Libraries
            if (profile.SelectedLibraries.Count > 0)
            {
                sb.AppendLine("libraries:");
                
                foreach (var libraryName in profile.SelectedLibraries)
                {
                    sb.AppendLine($"  {libraryName}:");
                    sb.AppendLine("    remove_overlays: false");
                    
                    // Determine library type (Movies or TV Shows)
                    var library = profile.Plex.AvailableLibraries.FirstOrDefault(l => l.Name == libraryName);
                    string libraryType = GetLibraryMediaType(library?.Type);
                    
                    // Add collection files only if there are selected charts
                    var enabledCharts = profile.SelectedCharts.Where(c => c.Value).ToList();
                    if (enabledCharts.Count > 0)
                    {
                        sb.AppendLine("    collection_files:");
                        foreach (var chart in enabledCharts)
                        {
                            sb.AppendLine($"    - default: {chart.Key}");
                        }
                    }
                    
                    // Add overlay files only if there are overlays where main checkbox is enabled for this library type
                    var relevantOverlays = profile.OverlaySettings.Where(o => 
                        o.Value.IsEnabled && 
                        IsOverlayForLibraryType(o.Key, libraryType)).ToList();
                    
                    if (relevantOverlays.Count > 0)
                    {
                        sb.AppendLine("    overlay_files:");
                        var processedOverlays = new HashSet<string>(); // Track processed overlays to prevent duplicates
                        foreach (var overlay in relevantOverlays)
                        {
                            // Use only the base overlay type, not the full key with media type and builder level
                            var overlayName = overlay.Value.OverlayType;
                            
                            // Clean overlay name - remove any lingering _TV or _Movie suffixes from legacy data
                            if (overlayName.EndsWith("_TV"))
                            {
                                overlayName = overlayName.Substring(0, overlayName.Length - "_TV".Length);
                            }
                            else if (overlayName.EndsWith("_Movie") || overlayName.EndsWith("_Movies"))
                            {
                                overlayName = overlayName.EndsWith("_Movies") 
                                    ? overlayName.Substring(0, overlayName.Length - "_Movies".Length)
                                    : overlayName.Substring(0, overlayName.Length - "_Movie".Length);
                            }
                            
                            // Get the overlay info to check supported levels
                            OverlayInfo overlayInfo = null;
                            if (OverlayDefaults.AllOverlays.ContainsKey(overlayName))
                            {
                                overlayInfo = OverlayDefaults.AllOverlays[overlayName];
                            }
                            
                            // Generate overlay entries based on configuration
                            if (overlay.Value.IsEnabled)
                            {
                                // Create a unique key for this overlay configuration to prevent duplicates
                                var configKey = $"{overlayName}_{string.Join(",", overlay.Value.TemplateVariables.Keys.OrderBy(k => k))}";
                                if (!processedOverlays.Contains(configKey))
                                {
                                    processedOverlays.Add(configKey);
                                    GenerateSimpleOverlayEntries(sb, overlay.Value, overlayName);
                                }
                            }
                        }
                        
                        // Add operations section if needed for rating overlays
                        AddOperationsSection(sb, libraryName, relevantOverlays);
                    }
                    
                    sb.AppendLine();
                }
            }

            // Settings
            sb.AppendLine("settings:");
            sb.AppendLine("  run_order:");
            sb.AppendLine("  - operations");
            sb.AppendLine("  - metadata");
            sb.AppendLine("  - collections");
            sb.AppendLine("  - overlays");
            sb.AppendLine($"  cache: {profile.Settings.Cache.ToString().ToLower()}");
            sb.AppendLine($"  cache_expiration: {profile.Settings.CacheExpiration}");
            sb.AppendLine("  asset_directory:");
            sb.AppendLine("  - config/assets");
            sb.AppendLine("  asset_folders: true");
            sb.AppendLine("  asset_depth: 0");
            sb.AppendLine("  create_asset_folders: false");
            sb.AppendLine("  prioritize_assets: false");
            sb.AppendLine("  dimensional_asset_rename: false");
            sb.AppendLine("  download_url_assets: false");
            sb.AppendLine("  show_missing_season_assets: false");
            sb.AppendLine("  show_missing_episode_assets: false");
            sb.AppendLine("  show_asset_not_needed: true");
            sb.AppendLine($"  sync_mode: {profile.Settings.SyncMode}");
            sb.AppendLine($"  minimum_items: {profile.Settings.MinimumItems}");
            sb.AppendLine("  default_collection_order: release");
            sb.AppendLine($"  delete_below_minimum: {profile.Settings.DeleteBelowMinimum.ToString().ToLower()}");
            sb.AppendLine("  delete_not_scheduled: false");
            sb.AppendLine("  run_again_delay: 2");
            sb.AppendLine("  missing_only_released: false");
            sb.AppendLine("  only_filter_missing: false");
            sb.AppendLine($"  show_unmanaged: {profile.Settings.ShowUnmanaged.ToString().ToLower()}");
            sb.AppendLine("  show_unconfigured: true");
            sb.AppendLine("  show_filtered: false");
            sb.AppendLine("  show_unfiltered: false");
            sb.AppendLine("  show_options: true");
            sb.AppendLine($"  show_missing: {profile.Settings.ShowMissing.ToString().ToLower()}");
            sb.AppendLine("  show_missing_assets: true");
            sb.AppendLine("  save_report: false");
            sb.AppendLine("  tvdb_language: eng");
            sb.AppendLine("  ignore_ids:");
            sb.AppendLine("  ignore_imdb_ids:");
            sb.AppendLine("  item_refresh_delay: 0");
            sb.AppendLine("  playlist_sync_to_users:");
            sb.AppendLine("  playlist_exclude_users:");
            sb.AppendLine("  playlist_report: false");
            sb.AppendLine($"  verify_ssl: {profile.Settings.VerifySSL.ToString().ToLower()}");
            sb.AppendLine("  custom_repo:");
            sb.AppendLine($"  overlay_artwork_filetype: {profile.Settings.OverlayArtworkFiletype}");
            sb.AppendLine($"  overlay_artwork_quality: {profile.Settings.OverlayArtworkQuality}");
            sb.AppendLine();

            // Optional services
            AddOptionalServices(sb, profile);

            return sb.ToString();
        }

        private string GetLibraryMediaType(string plexLibraryType)
        {
            if (string.IsNullOrEmpty(plexLibraryType))
                return "Movies"; // Default fallback
                
            // Convert Plex library types to our media types
            switch (plexLibraryType.ToLower())
            {
                case "movie":
                    return "Movies";
                case "show":
                    return "TV Shows";
                default:
                    return "Movies"; // Default to Movies for unknown types
            }
        }

        private void GenerateSimpleOverlayEntries(StringBuilder sb, OverlayConfiguration overlayConfig, string overlayName)
        {
            if (overlayConfig.TemplateVariables.ContainsKey("builder_levels"))
            {
                // Multi-level overlay: generate one entry per builder level
                var builderLevelsObj = overlayConfig.TemplateVariables["builder_levels"];
                List<string> levels;
                
                if (builderLevelsObj is List<string> levelsList)
                {
                    levels = levelsList;
                }
                else
                {
                    // Fallback: try to parse as comma-separated string
                    levels = builderLevelsObj.ToString().Split(',').Select(l => l.Trim()).ToList();
                }
                
                foreach (var level in levels)
                {
                    var trimmedLevel = level.Trim();
                    sb.AppendLine($"      - default: {overlayName}");
                    
                    if (trimmedLevel != "show")
                    {
                        sb.AppendLine("        template_variables:");
                        sb.AppendLine($"          builder_level: {trimmedLevel}");
                        
                        // Add other template variables for non-show levels (like ratings)
                        foreach (var templateVar in overlayConfig.TemplateVariables)
                        {
                            if (templateVar.Key != "builder_levels")
                            {
                                var formattedValue = FormatYamlValue(templateVar.Value);
                                sb.AppendLine($"          {templateVar.Key}: {formattedValue}");
                            }
                        }
                    }
                    else
                    {
                        // Show level: add other template variables without builder_level
                        if (overlayConfig.TemplateVariables.Count > 1) // More than just builder_levels
                        {
                            sb.AppendLine("        template_variables:");
                            foreach (var templateVar in overlayConfig.TemplateVariables)
                            {
                                if (templateVar.Key != "builder_levels")
                                {
                                    var formattedValue = FormatYamlValue(templateVar.Value);
                                    sb.AppendLine($"          {templateVar.Key}: {formattedValue}");
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                // Single entry
                sb.AppendLine($"      - default: {overlayName}");
                
                if (overlayConfig.TemplateVariables.Count > 0)
                {
                    sb.AppendLine("        template_variables:");
                    foreach (var templateVar in overlayConfig.TemplateVariables)
                    {
                        var formattedValue = FormatYamlValue(templateVar.Value);
                        sb.AppendLine($"          {templateVar.Key}: {formattedValue}");
                    }
                }
            }
        }

        private string FormatYamlValue(object value)
        {
            if (value == null)
                return "null";
                
            if (value is string stringValue)
                return stringValue;
                
            if (value is bool boolValue)
                return boolValue.ToString().ToLower();
                
            if (value is int || value is long || value is double || value is float)
                return value.ToString();
                
            if (value is List<string> listValue)
            {
                // List<string> should not be serialized as template variables
                // Return empty string to prevent YAML corruption
                return "";
            }
                
            // Fallback for other types
            return value.ToString();
        }

        private bool IsOverlayForLibraryType(string overlayKey, string libraryType)
        {
            // Overlay keys are in format: "overlayId_MediaType" (e.g., "resolution_Movies", "audio_codec_TV_Shows")
            // Convert library type to underscore format to match how overlays are stored
            var normalizedLibraryType = libraryType.Replace(" ", "_");
            var expectedSuffix = $"_{normalizedLibraryType}";
            return overlayKey.EndsWith(expectedSuffix, StringComparison.OrdinalIgnoreCase);
        }

        private void AddOptionalServices(StringBuilder sb, KometaProfile profile)
        {
            // Only add services that are enabled
            var servicesToCheck = new[] { "tautulli", "radarr", "sonarr", "gotify", "ntfy", "github", "omdb", "mdblist", "notifiarr", "anidb", "trakt", "mal" };
            
            foreach (var serviceId in servicesToCheck)
            {
                // Check if service is enabled
                if (profile.EnabledServices.ContainsKey(serviceId) && profile.EnabledServices[serviceId])
                {
                    switch (serviceId)
                    {
                        case "tautulli":
                            AddTautulliConfig(sb, profile);
                            break;
                        case "radarr":
                            AddRadarrConfig(sb, profile);
                            break;
                        case "sonarr":
                            AddSonarrConfig(sb, profile);
                            break;
                        case "gotify":
                            AddGotifyConfig(sb, profile);
                            break;
                        case "ntfy":
                            AddNtfyConfig(sb, profile);
                            break;
                        case "github":
                            AddGitHubConfig(sb, profile);
                            break;
                        case "omdb":
                            AddOmdbConfig(sb, profile);
                            break;
                        case "mdblist":
                            AddMdbListConfig(sb, profile);
                            break;
                        case "notifiarr":
                            AddNotifiarrConfig(sb, profile);
                            break;
                        case "anidb":
                            AddAnidbConfig(sb, profile);
                            break;
                        case "trakt":
                            AddTraktConfig(sb, profile);
                            break;
                        case "mal":
                            AddMalConfig(sb, profile);
                            break;
                    }
                }
            }
        }

        private void AddOperationsSection(StringBuilder sb, string libraryName, List<KeyValuePair<string, OverlayConfiguration>> relevantOverlays)
        {
            var operations = new List<string>();
            
            // Check for rating overlays and determine operations needed - only if advanced variables are enabled
            var ratingOverlay = relevantOverlays.FirstOrDefault(o => o.Key.Contains("ratings"));
            if (ratingOverlay.Value != null && ratingOverlay.Value.UseAdvancedVariables)
            {
                var builderLevel = ratingOverlay.Value.BuilderLevel ?? "show";
                
                // Check what rating types are configured
                bool hasRating1 = ratingOverlay.Value.TemplateVariables.ContainsKey("rating1");
                bool hasRating2 = ratingOverlay.Value.TemplateVariables.ContainsKey("rating2");
                bool hasRating3 = ratingOverlay.Value.TemplateVariables.ContainsKey("rating3");
                
                if (builderLevel == "episode")
                {
                    // Episode-level operations
                    if (hasRating1 && ratingOverlay.Value.TemplateVariables["rating1"].ToString() == "critic")
                        operations.Add("      mass_episode_critic_rating_update: imdb");
                    if (hasRating2 && ratingOverlay.Value.TemplateVariables["rating2"].ToString() == "audience")
                        operations.Add("      mass_episode_audience_rating_update: tmdb");
                }
                else if (builderLevel == "show" || string.IsNullOrEmpty(builderLevel))
                {
                    // Show-level operations (also applies to Movies)
                    if (hasRating1 && ratingOverlay.Value.TemplateVariables["rating1"].ToString() == "user")
                        operations.Add("      mass_user_rating_update: mdb_tomatoes");
                    if (hasRating2 && ratingOverlay.Value.TemplateVariables["rating2"].ToString() == "critic")
                        operations.Add("      mass_critic_rating_update: imdb");
                    if (hasRating3 && ratingOverlay.Value.TemplateVariables["rating3"].ToString() == "audience")
                        operations.Add("      mass_audience_rating_update: tmdb");
                }
                // Season level doesn't need operations
            }
            
            // Add operations section if any operations are needed
            if (operations.Count > 0)
            {
                sb.AppendLine("    operations:");
                foreach (var operation in operations)
                {
                    sb.AppendLine(operation);
                }
            }
        }

        private void AddTautulliConfig(StringBuilder sb, KometaProfile profile)
        {
            sb.AppendLine("tautulli:");
            
            var url = profile.OptionalServices.ContainsKey("tautulli_url") ? profile.OptionalServices["tautulli_url"] : "";
            var apikey = profile.OptionalServices.ContainsKey("tautulli_key") ? profile.OptionalServices["tautulli_key"] : "";
            
            sb.AppendLine($"  url: {url}");
            sb.AppendLine($"  apikey: {apikey}");
            sb.AppendLine();
        }

        private void AddRadarrConfig(StringBuilder sb, KometaProfile profile)
        {
            sb.AppendLine("radarr:");
            
            var url = profile.OptionalServices.ContainsKey("radarr_url") ? profile.OptionalServices["radarr_url"] : "";
            var token = profile.OptionalServices.ContainsKey("radarr_key") ? profile.OptionalServices["radarr_key"] : "";
            
            sb.AppendLine($"  url: {url}");
            sb.AppendLine($"  token: {token}");
            sb.AppendLine("  add_missing: false");
            sb.AppendLine("  add_existing: false");
            sb.AppendLine("  upgrade_existing: false");
            sb.AppendLine("  monitor_existing: false");
            sb.AppendLine("  root_folder_path: \"S:/Movies\"");
            sb.AppendLine("  monitor: true");
            sb.AppendLine("  availability: announced");
            sb.AppendLine("  quality_profile: HD-1080p");
            sb.AppendLine("  tag:");
            sb.AppendLine("  search: false");
            sb.AppendLine("  radarr_path:");
            sb.AppendLine("  plex_path:");
            sb.AppendLine("  ignore_cache: false");
            sb.AppendLine();
        }

        private void AddSonarrConfig(StringBuilder sb, KometaProfile profile)
        {
            sb.AppendLine("sonarr:");
            
            var url = profile.OptionalServices.ContainsKey("sonarr_url") ? profile.OptionalServices["sonarr_url"] : "";
            var token = profile.OptionalServices.ContainsKey("sonarr_key") ? profile.OptionalServices["sonarr_key"] : "";
            
            sb.AppendLine($"  url: {url}");
            sb.AppendLine($"  token: {token}");
            sb.AppendLine("  add_missing: false");
            sb.AppendLine("  add_existing: false");
            sb.AppendLine("  upgrade_existing: false");
            sb.AppendLine("  monitor_existing: false");
            sb.AppendLine("  root_folder_path: \"S:/TV Shows\"");
            sb.AppendLine("  monitor: all");
            sb.AppendLine("  quality_profile: HD-1080p");
            sb.AppendLine("  language_profile: English");
            sb.AppendLine("  series_type: standard");
            sb.AppendLine("  season_folder: true");
            sb.AppendLine("  tag:");
            sb.AppendLine("  search: false");
            sb.AppendLine("  cutoff_search: false");
            sb.AppendLine("  sonarr_path:");
            sb.AppendLine("  plex_path:");
            sb.AppendLine("  ignore_cache: false");
            sb.AppendLine();
        }

        private void AddGotifyConfig(StringBuilder sb, KometaProfile profile)
        {
            sb.AppendLine("gotify:");
            
            var url = profile.OptionalServices.ContainsKey("gotify_url") ? profile.OptionalServices["gotify_url"] : "";
            var token = profile.OptionalServices.ContainsKey("gotify_key") ? profile.OptionalServices["gotify_key"] : "";
            
            sb.AppendLine($"  url: {url}");
            sb.AppendLine($"  token: {token}");
            sb.AppendLine();
        }

        private void AddNtfyConfig(StringBuilder sb, KometaProfile profile)
        {
            sb.AppendLine("ntfy:");
            
            var url = profile.OptionalServices.ContainsKey("ntfy_url") ? profile.OptionalServices["ntfy_url"] : "";
            var token = profile.OptionalServices.ContainsKey("ntfy_key") ? profile.OptionalServices["ntfy_key"] : "";
            
            sb.AppendLine($"  url: {url}");
            sb.AppendLine($"  token: {token}");
            sb.AppendLine("  topic:");
            sb.AppendLine();
        }

        private void AddGitHubConfig(StringBuilder sb, KometaProfile profile)
        {
            sb.AppendLine("github:");
            
            var token = profile.OptionalServices.ContainsKey("github_key") ? profile.OptionalServices["github_key"] : "";
            
            sb.AppendLine($"  token: {token}");
            sb.AppendLine();
        }

        private void AddOmdbConfig(StringBuilder sb, KometaProfile profile)
        {
            sb.AppendLine("omdb:");
            
            var apikey = profile.OptionalServices.ContainsKey("omdb_key") ? profile.OptionalServices["omdb_key"] : "";
            
            sb.AppendLine($"  apikey: {apikey}");
            sb.AppendLine("  cache_expiration: 60");
            sb.AppendLine();
        }

        private void AddMdbListConfig(StringBuilder sb, KometaProfile profile)
        {
            sb.AppendLine("mdblist:");
            
            var apikey = profile.OptionalServices.ContainsKey("mdblist_key") ? profile.OptionalServices["mdblist_key"] : "";
            
            sb.AppendLine($"  apikey: {apikey}");
            sb.AppendLine("  cache_expiration: 60");
            sb.AppendLine();
        }

        private void AddNotifiarrConfig(StringBuilder sb, KometaProfile profile)
        {
            sb.AppendLine("notifiarr:");
            
            var apikey = profile.OptionalServices.ContainsKey("notifiarr_key") ? profile.OptionalServices["notifiarr_key"] : "";
            
            sb.AppendLine($"  apikey: {apikey}");
            sb.AppendLine();
        }

        private void AddAnidbConfig(StringBuilder sb, KometaProfile profile)
        {
            sb.AppendLine("anidb:");
            
            var credentials = profile.OptionalServices.ContainsKey("anidb_key") ? profile.OptionalServices["anidb_key"] : "";
            
            sb.AppendLine($"  username: {credentials}");
            sb.AppendLine("  password:");
            sb.AppendLine("  cache_expiration: 60");
            sb.AppendLine("  client:");
            sb.AppendLine("  language: en");
            sb.AppendLine("  version: 1");
            sb.AppendLine();
        }

        private void AddTraktConfig(StringBuilder sb, KometaProfile profile)
        {
            sb.AppendLine("trakt:");
            
            var clientId = profile.OptionalServices.ContainsKey("trakt_client_id") ? profile.OptionalServices["trakt_client_id"] : "";
            var clientSecret = profile.OptionalServices.ContainsKey("trakt_client_secret") ? profile.OptionalServices["trakt_client_secret"] : "";
            var pin = profile.OptionalServices.ContainsKey("trakt_pin") ? profile.OptionalServices["trakt_pin"] : "";
            
            sb.AppendLine($"  client_id: {clientId}");
            sb.AppendLine($"  client_secret: {clientSecret}");
            sb.AppendLine($"  pin: {pin}");
            sb.AppendLine("  authorization:");
            sb.AppendLine("    access_token:");
            sb.AppendLine("    created_at:");
            sb.AppendLine("    expires_in:");
            sb.AppendLine("    refresh_token:");
            sb.AppendLine("    scope: public");
            sb.AppendLine("    token_type:");
            sb.AppendLine();
        }

        private void AddMalConfig(StringBuilder sb, KometaProfile profile)
        {
            sb.AppendLine("mal:");
            
            var clientId = profile.OptionalServices.ContainsKey("mal_client_id") ? profile.OptionalServices["mal_client_id"] : "";
            var clientSecret = profile.OptionalServices.ContainsKey("mal_client_secret") ? profile.OptionalServices["mal_client_secret"] : "";
            var cacheExpiration = profile.OptionalServices.ContainsKey("mal_cache_expiration") ? profile.OptionalServices["mal_cache_expiration"] : "60";
            var localhostUrl = profile.OptionalServices.ContainsKey("mal_localhost_url") ? profile.OptionalServices["mal_localhost_url"] : "";
            
            sb.AppendLine($"  client_id: {clientId}");
            sb.AppendLine($"  client_secret: {clientSecret}");
            sb.AppendLine($"  cache_expiration: {cacheExpiration}");
            sb.AppendLine($"  localhost_url: {localhostUrl}");
            sb.AppendLine("  authorization:");
            sb.AppendLine("    access_token:");
            sb.AppendLine("    expires_in:");
            sb.AppendLine("    refresh_token:");
            sb.AppendLine("    token_type:");
            sb.AppendLine();
        }

        public void SaveConfigToFile(string yamlContent, string filePath)
        {
            File.WriteAllText(filePath, yamlContent, Encoding.UTF8);
        }

        private string ExtractIpFromUrl(string url)
        {
            try
            {
                var uri = new Uri(url);
                return uri.Host;
            }
            catch
            {
                return "192.168.1.12"; // Default fallback
            }
        }
    }
}